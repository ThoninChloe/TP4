/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { META_KEY, META_OPTIONS_KEY, SELECTOR_META_KEY } from '../symbols';
/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function asReadonly(value) {
    return value;
}
/**
 * @record
 * @template T, U
 */
export function StateClassInternal() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.selectFromAppState;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
    /** @type {?} */
    MetaDataModel.prototype.instance;
}
/**
 * @record
 */
export function SharedSelectorOptions() { }
if (false) {
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.injectContainerState;
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.suppressErrors;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectFromAppState;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
    /** @type {?} */
    SelectorMetaDataModel.prototype.getSelectorOptions;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.depth;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
// closure variable used to store the global options
/** @type {?} */
let _globalSelectorOptions = {};
/** @type {?} */
export const globalSelectorOptions = asReadonly({
    /**
     * @return {?}
     */
    get() {
        return _globalSelectorOptions;
    },
    /**
     * @param {?} value
     * @return {?}
     */
    set(value) {
        _globalSelectorOptions = Object.assign({}, value);
    }
});
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null,
            getSelectorOptions: (/**
             * @return {?}
             */
            () => ({}))
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = paths.slice();
    return (/**
     * @param {?} obj
     * @return {?}
     */
    obj => copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    (acc, part) => acc && acc[part]), obj));
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        g => g === stateClass));
        if (!meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        const { name, children } = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        /** @type {?} */
        const meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    });
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        (dep) => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    k => visit(k)));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxPQUFPLEVBQ0wsUUFBUSxFQUNSLGdCQUFnQixFQUVoQixpQkFBaUIsRUFFbEIsTUFBTSxZQUFZLENBQUM7Ozs7OztBQUtwQixTQUFTLFVBQVUsQ0FBSSxLQUFRO0lBQzdCLE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQzs7Ozs7QUFHRCx3Q0FHQzs7Ozs7Ozs7Ozs7QUFLRCxxQ0FNQzs7Ozs7SUFMQyxxREFBYzs7Ozs7SUFFZCx3REFBb0I7Ozs7O0lBRXBCLDREQUFpRDs7Ozs7QUFHbkQsbUNBUUM7OztJQVBDLDZCQUFvQjs7SUFDcEIsZ0NBQStDOztJQUMvQyxpQ0FBYzs7SUFDZCw2QkFBb0I7O0lBQ3BCLDJDQUEyQzs7SUFDM0MsaUNBQWdDOztJQUNoQyxpQ0FBYzs7Ozs7QUFLaEIsMkNBR0M7OztJQUZDLHFEQUErQjs7SUFDL0IsK0NBQXlCOzs7OztBQUczQiwyQ0FNQzs7O0lBTEMsbURBQTJDOztJQUMzQywyQ0FBNEI7O0lBQzVCLCtDQUFvQjs7SUFDcEIsNkNBQTRCOztJQUM1QixtREFBZ0Q7Ozs7O0FBR2xELGlDQU1DOzs7SUFMQywyQkFBYTs7SUFDYiw4QkFBK0M7O0lBQy9DLCtCQUFjOztJQUNkLCtCQUFjOztJQUNkLDRCQUFjOzs7OztBQUdoQix1Q0FHQzs7O0lBRkMscUNBQWM7O0lBQ2QsbUNBQXNCOzs7Ozs7Ozs7QUFVeEIsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE1BQTBCO0lBQzVELElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFOztjQUM5QixlQUFlLEdBQWtCO1lBQ3JDLElBQUksRUFBRSxJQUFJO1lBQ1YsT0FBTyxFQUFFLEVBQUU7WUFDWCxRQUFRLEVBQUUsRUFBRTtZQUNaLElBQUksRUFBRSxJQUFJ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L0IsT0FBTyxDQUFDLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLElBQUksT0FBTyxHQUFHLEtBQUssVUFBVSxDQUFDO0FBQ2hGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIE1FVEFfS0VZLFxyXG4gIE1FVEFfT1BUSU9OU19LRVksXHJcbiAgTmd4c0NvbmZpZyxcclxuICBTRUxFQ1RPUl9NRVRBX0tFWSxcclxuICBTdG9yZU9wdGlvbnNcclxufSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgQWN0aW9uSGFuZGxlck1ldGFEYXRhIH0gZnJvbSAnLi4vYWN0aW9ucy9zeW1ib2xzJztcclxuXHJcbmltcG9ydCB7IE9iamVjdEtleU1hcCwgU3RhdGVDbGFzcyB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XHJcblxyXG5mdW5jdGlvbiBhc1JlYWRvbmx5PFQ+KHZhbHVlOiBUKTogUmVhZG9ubHk8VD4ge1xyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLy8gaW5zcGlyZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDM2NzQzODlcclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZUNsYXNzSW50ZXJuYWw8VCA9IGFueSwgVSA9IGFueT4gZXh0ZW5kcyBTdGF0ZUNsYXNzPFQ+IHtcclxuICBbTUVUQV9LRVldPzogTWV0YURhdGFNb2RlbDtcclxuICBbTUVUQV9PUFRJT05TX0tFWV0/OiBTdG9yZU9wdGlvbnM8VT47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFN0YXRlS2V5R3JhcGggPSBPYmplY3RLZXlNYXA8c3RyaW5nW10+O1xyXG5leHBvcnQgdHlwZSBTdGF0ZXNCeU5hbWUgPSBPYmplY3RLZXlNYXA8U3RhdGVDbGFzc0ludGVybmFsPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVPcGVyYXRpb25zPFQ+IHtcclxuICBnZXRTdGF0ZSgpOiBUO1xyXG5cclxuICBzZXRTdGF0ZSh2YWw6IFQpOiBUO1xyXG5cclxuICBkaXNwYXRjaChhY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8dm9pZD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWV0YURhdGFNb2RlbCB7XHJcbiAgbmFtZTogc3RyaW5nIHwgbnVsbDtcclxuICBhY3Rpb25zOiBPYmplY3RLZXlNYXA8QWN0aW9uSGFuZGxlck1ldGFEYXRhW10+O1xyXG4gIGRlZmF1bHRzOiBhbnk7XHJcbiAgcGF0aDogc3RyaW5nIHwgbnVsbDtcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZSB8IG51bGw7XHJcbiAgY2hpbGRyZW4/OiBTdGF0ZUNsYXNzSW50ZXJuYWxbXTtcclxuICBpbnN0YW5jZTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTZWxlY3RGcm9tU3RhdGUgPSAoc3RhdGU6IGFueSkgPT4gYW55O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaGFyZWRTZWxlY3Rvck9wdGlvbnMge1xyXG4gIGluamVjdENvbnRhaW5lclN0YXRlPzogYm9vbGVhbjtcclxuICBzdXBwcmVzc0Vycm9ycz86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZSB8IG51bGw7XHJcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb24gfCBudWxsO1xyXG4gIGNvbnRhaW5lckNsYXNzOiBhbnk7XHJcbiAgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfCBudWxsO1xyXG4gIGdldFNlbGVjdG9yT3B0aW9uczogKCkgPT4gU2hhcmVkU2VsZWN0b3JPcHRpb25zO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcHBlZFN0b3JlIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbiAgZGVwdGg6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZXNBbmREZWZhdWx0cyB7XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBzdGF0ZXM6IE1hcHBlZFN0b3JlW107XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIENhbGxiYWNrPFQgPSBhbnksIFYgPSBhbnk+ID0gKC4uLmFyZ3M6IFZbXSkgPT4gVDtcclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBjbGFzcyBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzSW50ZXJuYWwpOiBNZXRhRGF0YU1vZGVsIHtcclxuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShNRVRBX0tFWSkpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YTogTWV0YURhdGFNb2RlbCA9IHtcclxuICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgYWN0aW9uczoge30sXHJcbiAgICAgIGRlZmF1bHRzOiB7fSxcclxuICAgICAgcGF0aDogbnVsbCxcclxuICAgICAgc2VsZWN0RnJvbUFwcFN0YXRlOiBudWxsLFxyXG4gICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgIGluc3RhbmNlOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIE1FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBnZXRTdG9yZU1ldGFkYXRhKHRhcmdldCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBzdGF0ZSBjbGFzcyBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yZU1ldGFkYXRhKHRhcmdldDogU3RhdGVDbGFzc0ludGVybmFsKTogTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtNRVRBX0tFWV0hO1xyXG59XHJcblxyXG4vLyBjbG9zdXJlIHZhcmlhYmxlIHVzZWQgdG8gc3RvcmUgdGhlIGdsb2JhbCBvcHRpb25zXHJcbmxldCBfZ2xvYmFsU2VsZWN0b3JPcHRpb25zOiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMgPSB7fTtcclxuXHJcbmV4cG9ydCBjb25zdCBnbG9iYWxTZWxlY3Rvck9wdGlvbnMgPSBhc1JlYWRvbmx5KHtcclxuICBnZXQoKTogUmVhZG9ubHk8U2hhcmVkU2VsZWN0b3JPcHRpb25zPiB7XHJcbiAgICByZXR1cm4gX2dsb2JhbFNlbGVjdG9yT3B0aW9ucztcclxuICB9LFxyXG4gIHNldCh2YWx1ZTogUmVhZG9ubHk8U2hhcmVkU2VsZWN0b3JPcHRpb25zPikge1xyXG4gICAgX2dsb2JhbFNlbGVjdG9yT3B0aW9ucyA9IHsgLi4udmFsdWUgfTtcclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQ6IEZ1bmN0aW9uKTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShTRUxFQ1RPUl9NRVRBX0tFWSkpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIG9yaWdpbmFsRm46IG51bGwsXHJcbiAgICAgIGNvbnRhaW5lckNsYXNzOiBudWxsLFxyXG4gICAgICBzZWxlY3Rvck5hbWU6IG51bGwsXHJcbiAgICAgIGdldFNlbGVjdG9yT3B0aW9uczogKCkgPT4gKHt9KVxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBTRUxFQ1RPUl9NRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0OiBhbnkpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIHJldHVybiB0YXJnZXRbU0VMRUNUT1JfTUVUQV9LRVldO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGFzIGZhc3QgYXMgdGhlIGBmYXN0UHJvcEdldHRlcmAgYnV0IGlzIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBjb21wbGlhbnQuXHJcbiAqIFNlZSBwZXJmIGhpdDogaHR0cHM6Ly9qc3BlcmYuY29tL2Zhc3QtdmFsdWUtZ2V0dGVyLWdpdmVuLXBhdGgvMVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XHJcbiAgY29uc3QgY29weU9mUGF0aHMgPSBwYXRocy5zbGljZSgpO1xyXG4gIHJldHVybiBvYmogPT4gY29weU9mUGF0aHMucmVkdWNlKChhY2M6IGFueSwgcGFydDogc3RyaW5nKSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbjpcclxuICogLSBwbHVjayAoT2JzZXJ2YWJsZSBvcGVyYXRvcilcclxuICogLSBtZW1vaXplXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGZhc3RQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XHJcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRocztcclxuICBsZXQgc2VnID0gJ3N0b3JlLicgKyBzZWdtZW50c1swXTtcclxuICBsZXQgaSA9IDA7XHJcbiAgY29uc3QgbCA9IHNlZ21lbnRzLmxlbmd0aDtcclxuXHJcbiAgbGV0IGV4cHIgPSBzZWc7XHJcbiAgd2hpbGUgKCsraSA8IGwpIHtcclxuICAgIGV4cHIgPSBleHByICsgJyAmJiAnICsgKHNlZyA9IHNlZyArICcuJyArIHNlZ21lbnRzW2ldKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzdG9yZScsICdyZXR1cm4gJyArIGV4cHIgKyAnOycpO1xyXG5cclxuICByZXR1cm4gPCh4OiBhbnkpID0+IGFueT5mbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJvcEdldHRlcihwYXRoczogc3RyaW5nW10sIGNvbmZpZzogTmd4c0NvbmZpZykge1xyXG4gIGlmIChjb25maWcgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkuc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5KSB7XHJcbiAgICByZXR1cm4gY29tcGxpYW50UHJvcEdldHRlcihwYXRocyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYXN0UHJvcEdldHRlcihwYXRocyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RhdGVzLCBpdCB3aWxsIHJldHVybiBhIG9iamVjdCBncmFwaC4gRXhhbXBsZTpcclxuICogICAgY29uc3Qgc3RhdGVzID0gW1xyXG4gKiAgICAgIENhcnQsXHJcbiAqICAgICAgQ2FydFNhdmVkLFxyXG4gKiAgICAgIENhcnRTYXZlZEl0ZW1zXHJcbiAqICAgIF1cclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHcmFwaChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogU3RhdGVLZXlHcmFwaCB7XHJcbiAgY29uc3QgZmluZE5hbWUgPSAoc3RhdGVDbGFzczogU3RhdGVDbGFzc0ludGVybmFsKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcclxuICAgIGlmICghbWV0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfS4gXFxyXFxuWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBhZGQgc3RhdGVzIHRvIG1vZHVsZWBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWV0YVtNRVRBX0tFWV0hLm5hbWUhO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzdGF0ZUNsYXNzZXMucmVkdWNlPFN0YXRlS2V5R3JhcGg+KFxyXG4gICAgKHJlc3VsdDogU3RhdGVLZXlHcmFwaCwgc3RhdGVDbGFzczogU3RhdGVDbGFzc0ludGVybmFsKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgbmFtZSwgY2hpbGRyZW4gfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcclxuICAgICAgcmVzdWx0W25hbWUhXSA9IChjaGlsZHJlbiB8fCBbXSkubWFwKGZpbmROYW1lKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICB7fVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHN0YXRlcyBhcnJheSwgcmV0dXJucyBvYmplY3QgZ3JhcGhcclxuICogcmV0dXJuaW5nIHRoZSBuYW1lIGFuZCBzdGF0ZSBtZXRhZGF0YS4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiB7IG1ldGFkYXRhIH1cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBuYW1lVG9TdGF0ZShzdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogT2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3NJbnRlcm5hbD4ge1xyXG4gIHJldHVybiBzdGF0ZXMucmVkdWNlPE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzSW50ZXJuYWw+PihcclxuICAgIChyZXN1bHQ6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzSW50ZXJuYWw+LCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcclxuICAgICAgY29uc3QgbWV0YSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcclxuICAgICAgcmVzdWx0W21ldGEubmFtZSFdID0gc3RhdGVDbGFzcztcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICB7fVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCByZWxhdGlvbnNoaXAgZ3JhcGggd2lsbCByZXR1cm4gdGhlIGZ1bGwgcGF0aFxyXG4gKiBmb3IgdGhlIGNoaWxkIGl0ZW1zLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCByID0ge1xyXG4gKiAgICBjYXJ0OiAnY2FydCcsXHJcbiAqICAgIHNhdmVkOiAnY2FydC5zYXZlZCcsXHJcbiAqICAgIGl0ZW1zOiAnY2FydC5zYXZlZC5pdGVtcydcclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnVsbFBhcmVudFBhdGgoXHJcbiAgb2JqOiBTdGF0ZUtleUdyYXBoLFxyXG4gIG5ld09iajogT2JqZWN0S2V5TWFwPHN0cmluZz4gPSB7fVxyXG4pOiBPYmplY3RLZXlNYXA8c3RyaW5nPiB7XHJcbiAgY29uc3QgdmlzaXQgPSAoY2hpbGQ6IFN0YXRlS2V5R3JhcGgsIGtleVRvRmluZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQoY2hpbGQsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQob2JqLCBrZXkpO1xyXG4gICAgICBuZXdPYmpba2V5XSA9IHBhcmVudCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdPYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCBncmFwaCwgaXQgd2lsbCByZXR1cm4gdGhlIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHJlc3VsdHMgPSBbXHJcbiAqICAgICdpdGVtcycsXHJcbiAqICAgICdzYXZlZCcsXHJcbiAqICAgICdjYXJ0J1xyXG4gKiAgXTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvcG9sb2dpY2FsU29ydChncmFwaDogU3RhdGVLZXlHcmFwaCk6IHN0cmluZ1tdIHtcclxuICBjb25zdCBzb3J0ZWQ6IHN0cmluZ1tdID0gW107XHJcbiAgY29uc3QgdmlzaXRlZDogT2JqZWN0S2V5TWFwPGJvb2xlYW4+ID0ge307XHJcblxyXG4gIGNvbnN0IHZpc2l0ID0gKG5hbWU6IHN0cmluZywgYW5jZXN0b3JzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xyXG4gICAgICBhbmNlc3RvcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhbmNlc3RvcnMucHVzaChuYW1lKTtcclxuICAgIHZpc2l0ZWRbbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgIGdyYXBoW25hbWVdLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChhbmNlc3RvcnMuaW5kZXhPZihkZXApID49IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgQ2lyY3VsYXIgZGVwZW5kZW5jeSAnJHtkZXB9JyBpcyByZXF1aXJlZCBieSAnJHtuYW1lfSc6ICR7YW5jZXN0b3JzLmpvaW4oJyAtPiAnKX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZpc2l0ZWRbZGVwXSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmlzaXQoZGVwLCBhbmNlc3RvcnMuc2xpY2UoMCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHNvcnRlZC5pbmRleE9mKG5hbWUpIDwgMCkge1xyXG4gICAgICBzb3J0ZWQucHVzaChuYW1lKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBPYmplY3Qua2V5cyhncmFwaCkuZm9yRWFjaChrID0+IHZpc2l0KGspKTtcclxuXHJcbiAgcmV0dXJuIHNvcnRlZC5yZXZlcnNlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBvYmplY3Qgb3Igbm90LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqOiBhbnkpIHtcclxuICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4iXX0=