(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@ngxs/store/internals'), require('@angular/common'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ngxs/store', ['exports', '@angular/core', '@ngxs/store/internals', '@angular/common', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.ngxs = global.ngxs || {}, global.ngxs.store = {}), global.ng.core, global.ngxs.store.internals, global.ng.common, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, internals, common, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DispatchOutsideZoneNgxsExecutionStrategy = /** @class */ (function () {
        function DispatchOutsideZoneNgxsExecutionStrategy(_ngZone, _platformId) {
            this._ngZone = _ngZone;
            this._platformId = _platformId;
            this.verifyZoneIsNotNooped(this._ngZone);
        }
        /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        DispatchOutsideZoneNgxsExecutionStrategy.prototype.enter = /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            if (common.isPlatformServer(this._platformId)) {
                return this.runInsideAngular(func);
            }
            return this.runOutsideAngular(func);
        };
        /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        DispatchOutsideZoneNgxsExecutionStrategy.prototype.leave = /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            return this.runInsideAngular(func);
        };
        /**
         * @private
         * @template T
         * @param {?} func
         * @return {?}
         */
        DispatchOutsideZoneNgxsExecutionStrategy.prototype.runInsideAngular = /**
         * @private
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            if (core.NgZone.isInAngularZone()) {
                return func();
            }
            return this._ngZone.run(func);
        };
        /**
         * @private
         * @template T
         * @param {?} func
         * @return {?}
         */
        DispatchOutsideZoneNgxsExecutionStrategy.prototype.runOutsideAngular = /**
         * @private
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            if (core.NgZone.isInAngularZone()) {
                return this._ngZone.runOutsideAngular(func);
            }
            return func();
        };
        /**
         * @private
         * @param {?} _
         * @return {?}
         */
        DispatchOutsideZoneNgxsExecutionStrategy.prototype.verifyZoneIsNotNooped = /**
         * @private
         * @param {?} _
         * @return {?}
         */
        function (_) {
            /* - Removed because unsafe for Angular 5 - investigate
            if (ngZone instanceof NoopNgZone) {
              console.warn(
                'Your application was bootstrapped with nooped zone and your execution strategy requires an ngZone'
              );
            }
            */
        };
        DispatchOutsideZoneNgxsExecutionStrategy.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DispatchOutsideZoneNgxsExecutionStrategy.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: String, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        return DispatchOutsideZoneNgxsExecutionStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ROOT_STATE_TOKEN = new core.InjectionToken('ROOT_STATE_TOKEN');
    /** @type {?} */
    var FEATURE_STATE_TOKEN = new core.InjectionToken('FEATURE_STATE_TOKEN');
    /** @type {?} */
    var NGXS_PLUGINS = new core.InjectionToken('NGXS_PLUGINS');
    /** @type {?} */
    var NG_TEST_MODE = new core.InjectionToken('NG_TEST_MODE');
    /** @type {?} */
    var NG_DEV_MODE = new core.InjectionToken('NG_DEV_MODE');
    /** @type {?} */
    var META_KEY = 'NGXS_META';
    /** @type {?} */
    var META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
    /** @type {?} */
    var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
    /**
     * The NGXS config settings.
     */
    var NgxsConfig = /** @class */ (function () {
        function NgxsConfig() {
            /**
             * Defining the default state before module initialization
             * This is convenient if we need to create a define our own set of states.
             * @deprecated will be removed after v4
             * (default: {})
             */
            this.defaultsState = {};
            /**
             * Defining shared selector options
             */
            this.selectorOptions = {
                injectContainerState: true,
                // TODO: default is true in v3, will change in v4
                suppressErrors: true // TODO: default is true in v3, will change in v4
            };
            this.compatibility = {
                strictContentSecurityPolicy: false
            };
            this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;
        }
        NgxsConfig.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NgxsConfig.ctorParameters = function () { return []; };
        return NgxsConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /*
     * Internal execution strategy injection token
     */
    /** @type {?} */
    var NGXS_EXECUTION_STRATEGY = new core.InjectionToken('NGXS_EXECUTION_STRATEGY');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */
    function asReadonly(value) {
        return value;
    }
    /**
     * Ensures metadata is attached to the class and returns it.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function ensureStoreMetadata(target) {
        if (!target.hasOwnProperty(META_KEY)) {
            /** @type {?} */
            var defaultMetadata = {
                name: null,
                actions: {},
                defaults: {},
                path: null,
                selectFromAppState: null,
                children: [],
                instance: null
            };
            Object.defineProperty(target, META_KEY, { value: defaultMetadata });
        }
        return getStoreMetadata(target);
    }
    /**
     * Get the metadata attached to the state class if it exists.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function getStoreMetadata(target) {
        return (/** @type {?} */ (target[META_KEY]));
    }
    // closure variable used to store the global options
    /** @type {?} */
    var _globalSelectorOptions = {};
    /** @type {?} */
    var globalSelectorOptions = asReadonly({
        get: /**
         * @return {?}
         */
        function () {
            return _globalSelectorOptions;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _globalSelectorOptions = __assign({}, value);
        }
    });
    /**
     * Ensures metadata is attached to the selector and returns it.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function ensureSelectorMetadata(target) {
        if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
            /** @type {?} */
            var defaultMetadata = {
                selectFromAppState: null,
                originalFn: null,
                containerClass: null,
                selectorName: null,
                getSelectorOptions: (/**
                 * @return {?}
                 */
                function () { return ({}); })
            };
            Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
        }
        return getSelectorMetadata(target);
    }
    /**
     * Get the metadata attached to the selector if it exists.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function getSelectorMetadata(target) {
        return target[SELECTOR_META_KEY];
    }
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
     * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
     *
     * @ignore
     * @param {?} paths
     * @return {?}
     */
    function compliantPropGetter(paths) {
        /** @type {?} */
        var copyOfPaths = paths.slice();
        return (/**
         * @param {?} obj
         * @return {?}
         */
        function (obj) { return copyOfPaths.reduce((/**
         * @param {?} acc
         * @param {?} part
         * @return {?}
         */
        function (acc, part) { return acc && acc[part]; }), obj); });
    }
    /**
     * The generated function is faster than:
     * - pluck (Observable operator)
     * - memoize
     *
     * @ignore
     * @param {?} paths
     * @return {?}
     */
    function fastPropGetter(paths) {
        /** @type {?} */
        var segments = paths;
        /** @type {?} */
        var seg = 'store.' + segments[0];
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var l = segments.length;
        /** @type {?} */
        var expr = seg;
        while (++i < l) {
            expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
        }
        /** @type {?} */
        var fn = new Function('store', 'return ' + expr + ';');
        return (/** @type {?} */ (fn));
    }
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * @ignore
     * @param {?} paths
     * @param {?} config
     * @return {?}
     */
    function propGetter(paths, config) {
        if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
            return compliantPropGetter(paths);
        }
        else {
            return fastPropGetter(paths);
        }
    }
    /**
     * Given an array of states, it will return a object graph. Example:
     *    const states = [
     *      Cart,
     *      CartSaved,
     *      CartSavedItems
     *    ]
     *
     * would return:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * @ignore
     * @param {?} stateClasses
     * @return {?}
     */
    function buildGraph(stateClasses) {
        /** @type {?} */
        var findName = (/**
         * @param {?} stateClass
         * @return {?}
         */
        function (stateClass) {
            /** @type {?} */
            var meta = stateClasses.find((/**
             * @param {?} g
             * @return {?}
             */
            function (g) { return g === stateClass; }));
            if (!meta) {
                throw new Error("Child state not found: " + stateClass + ". \r\nYou may have forgotten to add states to module");
            }
            return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
        });
        return stateClasses.reduce((/**
         * @param {?} result
         * @param {?} stateClass
         * @return {?}
         */
        function (result, stateClass) {
            var _a = (/** @type {?} */ (stateClass[META_KEY])), name = _a.name, children = _a.children;
            result[(/** @type {?} */ (name))] = (children || []).map(findName);
            return result;
        }), {});
    }
    /**
     * Given a states array, returns object graph
     * returning the name and state metadata. Example:
     *
     *  const graph = {
     *    cart: { metadata }
     *  };
     *
     * @ignore
     * @param {?} states
     * @return {?}
     */
    function nameToState(states) {
        return states.reduce((/**
         * @param {?} result
         * @param {?} stateClass
         * @return {?}
         */
        function (result, stateClass) {
            /** @type {?} */
            var meta = (/** @type {?} */ (stateClass[META_KEY]));
            result[(/** @type {?} */ (meta.name))] = stateClass;
            return result;
        }), {});
    }
    /**
     * Given a object relationship graph will return the full path
     * for the child items. Example:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * would return:
     *
     *  const r = {
     *    cart: 'cart',
     *    saved: 'cart.saved',
     *    items: 'cart.saved.items'
     *  };
     *
     * @ignore
     * @param {?} obj
     * @param {?=} newObj
     * @return {?}
     */
    function findFullParentPath(obj, newObj) {
        if (newObj === void 0) { newObj = {}; }
        /** @type {?} */
        var visit = (/**
         * @param {?} child
         * @param {?} keyToFind
         * @return {?}
         */
        function (child, keyToFind) {
            for (var key in child) {
                if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                    /** @type {?} */
                    var parent_1 = visit(child, key);
                    return parent_1 !== null ? parent_1 + "." + key : key;
                }
            }
            return null;
        });
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                /** @type {?} */
                var parent_2 = visit(obj, key);
                newObj[key] = parent_2 ? parent_2 + "." + key : key;
            }
        }
        return newObj;
    }
    /**
     * Given a object graph, it will return the items topologically sorted Example:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * would return:
     *
     *  const results = [
     *    'items',
     *    'saved',
     *    'cart'
     *  ];
     *
     * @ignore
     * @param {?} graph
     * @return {?}
     */
    function topologicalSort(graph) {
        /** @type {?} */
        var sorted = [];
        /** @type {?} */
        var visited = {};
        /** @type {?} */
        var visit = (/**
         * @param {?} name
         * @param {?=} ancestors
         * @return {?}
         */
        function (name, ancestors) {
            if (ancestors === void 0) { ancestors = []; }
            if (!Array.isArray(ancestors)) {
                ancestors = [];
            }
            ancestors.push(name);
            visited[name] = true;
            graph[name].forEach((/**
             * @param {?} dep
             * @return {?}
             */
            function (dep) {
                if (ancestors.indexOf(dep) >= 0) {
                    throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
                }
                if (visited[dep]) {
                    return;
                }
                visit(dep, ancestors.slice(0));
            }));
            if (sorted.indexOf(name) < 0) {
                sorted.push(name);
            }
        });
        Object.keys(graph).forEach((/**
         * @param {?} k
         * @return {?}
         */
        function (k) { return visit(k); }));
        return sorted.reverse();
    }
    /**
     * Returns if the parameter is a object or not.
     *
     * @ignore
     * @param {?} obj
     * @return {?}
     */
    function isObject(obj) {
        return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns the type from an action instance/class.
     * @ignore
     * @param {?} action
     * @return {?}
     */
    function getActionTypeFromInstance(action) {
        if (action.constructor && action.constructor.type) {
            return action.constructor.type;
        }
        return action.type;
    }
    /**
     * Matches a action
     * @ignore
     * @param {?} action1
     * @return {?}
     */
    function actionMatcher(action1) {
        /** @type {?} */
        var type1 = getActionTypeFromInstance(action1);
        return (/**
         * @param {?} action2
         * @return {?}
         */
        function (action2) {
            return type1 === getActionTypeFromInstance(action2);
        });
    }
    /**
     * Set a deeply nested value. Example:
     *
     *   setValue({ foo: { bar: { eat: false } } },
     *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
     *
     * While it traverses it also creates new objects from top down.
     *
     * @ignore
     * @type {?}
     */
    var setValue = (/**
     * @param {?} obj
     * @param {?} prop
     * @param {?} val
     * @return {?}
     */
    function (obj, prop, val) {
        obj = __assign({}, obj);
        /** @type {?} */
        var split = prop.split('.');
        /** @type {?} */
        var lastIndex = split.length - 1;
        split.reduce((/**
         * @param {?} acc
         * @param {?} part
         * @param {?} index
         * @return {?}
         */
        function (acc, part, index) {
            if (index === lastIndex) {
                acc[part] = val;
            }
            else {
                acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : __assign({}, acc[part]);
            }
            return acc && acc[part];
        }), obj);
        return obj;
    });
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * @ignore
     * @type {?}
     */
    var getValue = (/**
     * @param {?} obj
     * @param {?} prop
     * @return {?}
     */
    function (obj, prop) {
        return prop.split('.').reduce((/**
         * @param {?} acc
         * @param {?} part
         * @return {?}
         */
        function (acc, part) { return acc && acc[part]; }), obj);
    });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will grab actions that have just been dispatched as well as actions that have completed
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofAction() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been dispatched
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionDispatched() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, ["DISPATCHED" /* Dispatched */]);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been successfully completed
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionSuccessful() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, ["SUCCESSFUL" /* Successful */]);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been canceled
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionCanceled() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, ["CANCELED" /* Canceled */]);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been completed
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionCompleted() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        /** @type {?} */
        var allowedStatuses = [
            "SUCCESSFUL" /* Successful */,
            "CANCELED" /* Canceled */,
            "ERRORED" /* Errored */
        ];
        return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just thrown an error
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionErrored() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, ["ERRORED" /* Errored */]);
    }
    /**
     * @template T
     * @param {?} allowedTypes
     * @param {?=} statuses
     * @param {?=} mapOperator
     * @return {?}
     */
    function ofActionOperator(allowedTypes, statuses, mapOperator) {
        if (mapOperator === void 0) { mapOperator = mapAction; }
        /** @type {?} */
        var allowedMap = createAllowedActionTypesMap(allowedTypes);
        /** @type {?} */
        var allowedStatusMap = statuses && createAllowedStatusesMap(statuses);
        return (/**
         * @param {?} o
         * @return {?}
         */
        function (o) {
            return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());
        });
    }
    /**
     * @param {?} allowedTypes
     * @param {?=} allowedStatuses
     * @return {?}
     */
    function filterStatus(allowedTypes, allowedStatuses) {
        return operators.filter((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) {
            /** @type {?} */
            var actionType = (/** @type {?} */ (getActionTypeFromInstance(ctx.action)));
            /** @type {?} */
            var typeMatch = allowedTypes[actionType];
            /** @type {?} */
            var statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;
            return typeMatch && statusMatch;
        }));
    }
    /**
     * @return {?}
     */
    function mapActionResult() {
        return operators.map((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var action = _a.action, status = _a.status, error = _a.error;
            return (/** @type {?} */ ({
                action: action,
                result: {
                    successful: "SUCCESSFUL" /* Successful */ === status,
                    canceled: "CANCELED" /* Canceled */ === status,
                    error: error
                }
            }));
        }));
    }
    /**
     * @template T
     * @return {?}
     */
    function mapAction() {
        return operators.map((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return (/** @type {?} */ (ctx.action)); }));
    }
    /**
     * @param {?} types
     * @return {?}
     */
    function createAllowedActionTypesMap(types) {
        return types.reduce((/**
         * @param {?} filterMap
         * @param {?} klass
         * @return {?}
         */
        function (filterMap, klass) {
            filterMap[(/** @type {?} */ (getActionTypeFromInstance(klass)))] = true;
            return filterMap;
        }), (/** @type {?} */ ({})));
    }
    /**
     * @param {?} statuses
     * @return {?}
     */
    function createAllowedStatusesMap(statuses) {
        return statuses.reduce((/**
         * @param {?} filterMap
         * @param {?} status
         * @return {?}
         */
        function (filterMap, status) {
            filterMap[status] = true;
            return filterMap;
        }), (/** @type {?} */ ({})));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var InternalNgxsExecutionStrategy = /** @class */ (function () {
        function InternalNgxsExecutionStrategy(_executionStrategy) {
            this._executionStrategy = _executionStrategy;
        }
        /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        InternalNgxsExecutionStrategy.prototype.enter = /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            return this._executionStrategy.enter(func);
        };
        /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        InternalNgxsExecutionStrategy.prototype.leave = /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            return this._executionStrategy.leave(func);
        };
        InternalNgxsExecutionStrategy.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        InternalNgxsExecutionStrategy.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [NGXS_EXECUTION_STRATEGY,] }] }
        ]; };
        return InternalNgxsExecutionStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns operator that will run
     * `subscribe` outside of the ngxs execution context
     * @template T
     * @param {?} ngxsExecutionStrategy
     * @return {?}
     */
    function leaveNgxs(ngxsExecutionStrategy) {
        return (/**
         * @param {?} source
         * @return {?}
         */
        function (source) {
            return new rxjs.Observable((/**
             * @param {?} sink
             * @return {?}
             */
            function (sink) {
                return source.subscribe({
                    next: /**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) {
                        ngxsExecutionStrategy.leave((/**
                         * @return {?}
                         */
                        function () { return sink.next(value); }));
                    },
                    error: /**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) {
                        ngxsExecutionStrategy.leave((/**
                         * @return {?}
                         */
                        function () { return sink.error(error); }));
                    },
                    complete: /**
                     * @return {?}
                     */
                    function () {
                        ngxsExecutionStrategy.leave((/**
                         * @return {?}
                         */
                        function () { return sink.complete(); }));
                    }
                });
            }));
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
     * A standard Subject does not have this guarantee.
     * For example, given the following code:
     * ```typescript
     *   const subject = new Subject<string>();
     * subject.subscribe(value => {
     * if (value === 'start') subject.next('end');
     * });
     * subject.subscribe(value => { });
     * subject.next('start');
     * ```
     * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
     * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
     * @template T
     */
    var   /**
     * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
     * A standard Subject does not have this guarantee.
     * For example, given the following code:
     * ```typescript
     *   const subject = new Subject<string>();
     * subject.subscribe(value => {
     * if (value === 'start') subject.next('end');
     * });
     * subject.subscribe(value => { });
     * subject.next('start');
     * ```
     * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
     * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
     * @template T
     */
    OrderedSubject = /** @class */ (function (_super) {
        __extends(OrderedSubject, _super);
        function OrderedSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._itemQueue = [];
            _this._busyPushingNext = false;
            return _this;
        }
        /**
         * @param {?=} value
         * @return {?}
         */
        OrderedSubject.prototype.next = /**
         * @param {?=} value
         * @return {?}
         */
        function (value) {
            if (this._busyPushingNext) {
                this._itemQueue.unshift((/** @type {?} */ (value)));
                return;
            }
            this._busyPushingNext = true;
            _super.prototype.next.call(this, value);
            while (this._itemQueue.length > 0) {
                /** @type {?} */
                var nextValue = this._itemQueue.pop();
                _super.prototype.next.call(this, nextValue);
            }
            this._busyPushingNext = false;
        };
        return OrderedSubject;
    }(rxjs.Subject));
    /**
     * Internal Action stream that is emitted anytime an action is dispatched.
     */
    var InternalActions = /** @class */ (function (_super) {
        __extends(InternalActions, _super);
        function InternalActions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InternalActions.decorators = [
            { type: core.Injectable }
        ];
        return InternalActions;
    }(OrderedSubject));
    /**
     * Action stream that is emitted anytime an action is dispatched.
     *
     * You can listen to this in services to react without stores.
     */
    var Actions = /** @class */ (function (_super) {
        __extends(Actions, _super);
        function Actions(actions$, internalExecutionStrategy) {
            return _super.call(this, (/**
             * @param {?} observer
             * @return {?}
             */
            function (observer) {
                actions$
                    .pipe(leaveNgxs(internalExecutionStrategy))
                    .subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                function (res) { return observer.next(res); }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) { return observer.error(err); }), (/**
                 * @return {?}
                 */
                function () { return observer.complete(); }));
            })) || this;
        }
        Actions.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        Actions.ctorParameters = function () { return [
            { type: InternalActions },
            { type: InternalNgxsExecutionStrategy }
        ]; };
        return Actions;
    }(rxjs.Observable));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Composes a array of functions from left to right. Example:
     *
     *      compose([fn, final])(state, action);
     *
     * then the funcs have a signature like:
     *
     *      function fn (state, action, next) {
     *          console.log('here', state, action, next);
     *          return next(state, action);
     *      }
     *
     *      function final (state, action) {
     *          console.log('here', state, action);
     *          return state;
     *      }
     *
     * the last function should not call `next`.
     *
     * @ignore
     * @type {?}
     */
    var compose = (/**
     * @param {?} funcs
     * @return {?}
     */
    function (funcs) { return (/**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        /** @type {?} */
        var curr = (/** @type {?} */ (funcs.shift()));
        return curr.apply(void 0, __spread(args, [(/**
             * @param {...?} nextArgs
             * @return {?}
             */
            function () {
                var nextArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    nextArgs[_i] = arguments[_i];
                }
                return compose(funcs).apply(void 0, __spread(nextArgs));
            })]));
    }); });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * BehaviorSubject of the entire state.
     * @ignore
     */
    var StateStream = /** @class */ (function (_super) {
        __extends(StateStream, _super);
        function StateStream() {
            return _super.call(this, {}) || this;
        }
        StateStream.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateStream.ctorParameters = function () { return []; };
        return StateStream;
    }(rxjs.BehaviorSubject));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Plugin manager class
     * @ignore
     */
    var PluginManager = /** @class */ (function () {
        function PluginManager(_parentManager, _pluginHandlers) {
            this._parentManager = _parentManager;
            this._pluginHandlers = _pluginHandlers;
            this.plugins = [];
            this.registerHandlers();
        }
        /**
         * @private
         * @return {?}
         */
        PluginManager.prototype.registerHandlers = /**
         * @private
         * @return {?}
         */
        function () {
            this.plugins = this.getPlugins();
            this.registerPluginInManager(this.plugins);
        };
        /**
         * @private
         * @param {?} plugins
         * @return {?}
         */
        PluginManager.prototype.registerPluginInManager = /**
         * @private
         * @param {?} plugins
         * @return {?}
         */
        function (plugins) {
            var _a;
            if (this._parentManager) {
                (_a = this._parentManager.plugins).push.apply(_a, __spread(plugins));
            }
        };
        /**
         * @private
         * @return {?}
         */
        PluginManager.prototype.getPlugins = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var handlers = this._pluginHandlers || [];
            return handlers.map((/**
             * @param {?} plugin
             * @return {?}
             */
            function (plugin) { return (/** @type {?} */ ((plugin.handle ? plugin.handle.bind(plugin) : plugin))); }));
        };
        PluginManager.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PluginManager.ctorParameters = function () { return [
            { type: PluginManager, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: Array, decorators: [{ type: core.Inject, args: [NGXS_PLUGINS,] }, { type: core.Optional }] }
        ]; };
        return PluginManager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Internal Action result stream that is emitted when an action is completed.
     * This is used as a method of returning the action result to the dispatcher
     * for the observable returned by the dispatch(...) call.
     * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
     */
    var InternalDispatchedActionResults = /** @class */ (function (_super) {
        __extends(InternalDispatchedActionResults, _super);
        function InternalDispatchedActionResults() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InternalDispatchedActionResults.decorators = [
            { type: core.Injectable }
        ];
        return InternalDispatchedActionResults;
    }(rxjs.Subject));
    var InternalDispatcher = /** @class */ (function () {
        function InternalDispatcher(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy) {
            this._errorHandler = _errorHandler;
            this._actions = _actions;
            this._actionResults = _actionResults;
            this._pluginManager = _pluginManager;
            this._stateStream = _stateStream;
            this._ngxsExecutionStrategy = _ngxsExecutionStrategy;
        }
        /**
         * Dispatches event(s).
         */
        /**
         * Dispatches event(s).
         * @param {?} actionOrActions
         * @return {?}
         */
        InternalDispatcher.prototype.dispatch = /**
         * Dispatches event(s).
         * @param {?} actionOrActions
         * @return {?}
         */
        function (actionOrActions) {
            var _this = this;
            /** @type {?} */
            var result = this._ngxsExecutionStrategy.enter((/**
             * @return {?}
             */
            function () {
                return _this.dispatchByEvents(actionOrActions);
            }));
            result.subscribe({
                error: (/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    return _this._ngxsExecutionStrategy.leave((/**
                     * @return {?}
                     */
                    function () { return _this._errorHandler.handleError(error); }));
                })
            });
            return result.pipe(leaveNgxs(this._ngxsExecutionStrategy));
        };
        /**
         * @private
         * @param {?} actionOrActions
         * @return {?}
         */
        InternalDispatcher.prototype.dispatchByEvents = /**
         * @private
         * @param {?} actionOrActions
         * @return {?}
         */
        function (actionOrActions) {
            var _this = this;
            if (Array.isArray(actionOrActions)) {
                return rxjs.forkJoin(actionOrActions.map((/**
                 * @param {?} a
                 * @return {?}
                 */
                function (a) { return _this.dispatchSingle(a); })));
            }
            else {
                return this.dispatchSingle(actionOrActions);
            }
        };
        /**
         * @private
         * @param {?} action
         * @return {?}
         */
        InternalDispatcher.prototype.dispatchSingle = /**
         * @private
         * @param {?} action
         * @return {?}
         */
        function (action) {
            var _this = this;
            /** @type {?} */
            var prevState = this._stateStream.getValue();
            /** @type {?} */
            var plugins = this._pluginManager.plugins;
            return ((/** @type {?} */ (compose(__spread(plugins, [
                (/**
                 * @param {?} nextState
                 * @param {?} nextAction
                 * @return {?}
                 */
                function (nextState, nextAction) {
                    if (nextState !== prevState) {
                        _this._stateStream.next(nextState);
                    }
                    /** @type {?} */
                    var actionResult$ = _this.getActionResultStream(nextAction);
                    actionResult$.subscribe((/**
                     * @param {?} ctx
                     * @return {?}
                     */
                    function (ctx) { return _this._actions.next(ctx); }));
                    _this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                    return _this.createDispatchObservable(actionResult$);
                })
            ]))(prevState, action)))).pipe(operators.shareReplay());
        };
        /**
         * @private
         * @param {?} action
         * @return {?}
         */
        InternalDispatcher.prototype.getActionResultStream = /**
         * @private
         * @param {?} action
         * @return {?}
         */
        function (action) {
            return this._actionResults.pipe(operators.filter((/**
             * @param {?} ctx
             * @return {?}
             */
            function (ctx) { return ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */; })), operators.take(1), operators.shareReplay());
        };
        /**
         * @private
         * @param {?} actionResult$
         * @return {?}
         */
        InternalDispatcher.prototype.createDispatchObservable = /**
         * @private
         * @param {?} actionResult$
         * @return {?}
         */
        function (actionResult$) {
            var _this = this;
            return actionResult$
                .pipe(operators.exhaustMap((/**
             * @param {?} ctx
             * @return {?}
             */
            function (ctx) {
                switch (ctx.status) {
                    case "SUCCESSFUL" /* Successful */:
                        return rxjs.of(_this._stateStream.getValue());
                    case "ERRORED" /* Errored */:
                        return rxjs.throwError(ctx.error);
                    default:
                        return rxjs.EMPTY;
                }
            })))
                .pipe(operators.shareReplay());
        };
        InternalDispatcher.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        InternalDispatcher.ctorParameters = function () { return [
            { type: core.ErrorHandler },
            { type: InternalActions },
            { type: InternalDispatchedActionResults },
            { type: PluginManager },
            { type: StateStream },
            { type: InternalNgxsExecutionStrategy }
        ]; };
        return InternalDispatcher;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Object freeze code
     * https://github.com/jsdf/deep-freeze
     * @type {?}
     */
    var deepFreeze = (/**
     * @param {?} o
     * @return {?}
     */
    function (o) {
        Object.freeze(o);
        /** @type {?} */
        var oIsFunction = typeof o === 'function';
        /** @type {?} */
        var hasOwnProp = Object.prototype.hasOwnProperty;
        Object.getOwnPropertyNames(o).forEach((/**
         * @param {?} prop
         * @return {?}
         */
        function (prop) {
            if (hasOwnProp.call(o, prop) &&
                (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
                o[prop] !== null &&
                (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
                !Object.isFrozen(o[prop])) {
                deepFreeze(o[prop]);
            }
        }));
        return o;
    });

    var _a;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var VALIDATION_CODE = {
        STATE_NAME: 'STATE_NAME',
        STATE_UNIQUE: 'STATE_UNIQUE',
        STATE_NAME_PROPERTY: 'STATE_NAME_PROPERTY',
        STATE_DECORATOR: 'STATE_DECORATOR',
        INCORRECT_PRODUCTION: 'INCORRECT_PRODUCTION',
        INCORRECT_DEVELOPMENT: 'INCORRECT_DEVELOPMENT',
        SELECT_FACTORY_NOT_CONNECTED: 'SELECT_FACTORY_NOT_CONNECTED',
        ACTION_DECORATOR: 'ACTION_DECORATOR',
        SELECTOR_DECORATOR: 'SELECTOR_DECORATOR',
    };
    /** @type {?} */
    var CONFIG_MESSAGES = (_a = {},
        _a[VALIDATION_CODE.STATE_NAME] = (/**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            return name + " is not a valid state name. It needs to be a valid object property name.";
        }),
        _a[VALIDATION_CODE.STATE_NAME_PROPERTY] = (/**
         * @return {?}
         */
        function () { return "States must register a 'name' property"; }),
        _a[VALIDATION_CODE.STATE_UNIQUE] = (/**
         * @param {?} current
         * @param {?} newName
         * @param {?} oldName
         * @return {?}
         */
        function (current, newName, oldName) {
            return "State name '" + current + "' from " + newName + " already exists in " + oldName;
        }),
        _a[VALIDATION_CODE.STATE_DECORATOR] = (/**
         * @return {?}
         */
        function () { return 'States must be decorated with @State() decorator'; }),
        _a[VALIDATION_CODE.INCORRECT_PRODUCTION] = (/**
         * @return {?}
         */
        function () {
            return 'Angular is running in production mode but NGXS is still running in the development mode!\n' +
                'Please set developmentMode to false on the NgxsModule options when in production mode.\n' +
                'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        }),
        _a[VALIDATION_CODE.INCORRECT_DEVELOPMENT] = (/**
         * @return {?}
         */
        function () {
            return 'RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n' +
                'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        }),
        _a[VALIDATION_CODE.SELECT_FACTORY_NOT_CONNECTED] = (/**
         * @return {?}
         */
        function () {
            return 'SelectFactory not connected to store!';
        }),
        _a[VALIDATION_CODE.ACTION_DECORATOR] = (/**
         * @return {?}
         */
        function () {
            return '@Action() decorator cannot be used with static methods';
        }),
        _a[VALIDATION_CODE.SELECTOR_DECORATOR] = (/**
         * @return {?}
         */
        function () { return 'Selectors only work on methods'; }),
        _a);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HostEnvironment = /** @class */ (function () {
        function HostEnvironment(isTestMode, isDevMode) {
            this.isTestMode = isTestMode;
            this.isDevMode = isDevMode;
        }
        HostEnvironment.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        HostEnvironment.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [NG_DEV_MODE,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [NG_TEST_MODE,] }] }
        ]; };
        return HostEnvironment;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ConfigValidator = /** @class */ (function () {
        function ConfigValidator(_host, _config) {
            this._host = _host;
            this._config = _config;
        }
        Object.defineProperty(ConfigValidator.prototype, "isIncorrectProduction", {
            get: /**
             * @private
             * @return {?}
             */
            function () {
                return !this._host.isDevMode() && this._config.developmentMode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigValidator.prototype, "isIncorrectDevelopment", {
            get: /**
             * @private
             * @return {?}
             */
            function () {
                return this._host.isDevMode() && !this._config.developmentMode;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ConfigValidator.prototype.verifyDevMode = /**
         * @return {?}
         */
        function () {
            if (this._host.isTestMode()) {
                return;
            }
            if (this.isIncorrectProduction) {
                console.warn(CONFIG_MESSAGES[VALIDATION_CODE.INCORRECT_PRODUCTION]());
            }
            else if (this.isIncorrectDevelopment) {
                console.warn(CONFIG_MESSAGES[VALIDATION_CODE.INCORRECT_DEVELOPMENT]());
            }
        };
        ConfigValidator.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ConfigValidator.ctorParameters = function () { return [
            { type: HostEnvironment },
            { type: NgxsConfig }
        ]; };
        return ConfigValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State Context factory class
     * @ignore
     */
    var InternalStateOperations = /** @class */ (function () {
        function InternalStateOperations(_stateStream, _dispatcher, _config, configValidator) {
            this._stateStream = _stateStream;
            this._dispatcher = _dispatcher;
            this._config = _config;
            configValidator.verifyDevMode();
        }
        /**
         * Returns the root state operators.
         */
        /**
         * Returns the root state operators.
         * @return {?}
         */
        InternalStateOperations.prototype.getRootStateOperations = /**
         * Returns the root state operators.
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var rootStateOperations = {
                getState: (/**
                 * @return {?}
                 */
                function () { return _this._stateStream.getValue(); }),
                setState: (/**
                 * @param {?} newState
                 * @return {?}
                 */
                function (newState) { return _this._stateStream.next(newState); }),
                dispatch: (/**
                 * @param {?} actions
                 * @return {?}
                 */
                function (actions) { return _this._dispatcher.dispatch(actions); })
            };
            if (this._config.developmentMode) {
                return this.ensureStateAndActionsAreImmutable(rootStateOperations);
            }
            return rootStateOperations;
        };
        /**
         * @private
         * @param {?} root
         * @return {?}
         */
        InternalStateOperations.prototype.ensureStateAndActionsAreImmutable = /**
         * @private
         * @param {?} root
         * @return {?}
         */
        function (root) {
            return {
                getState: (/**
                 * @return {?}
                 */
                function () { return root.getState(); }),
                setState: (/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    /** @type {?} */
                    var frozenValue = deepFreeze(value);
                    return root.setState(frozenValue);
                }),
                dispatch: (/**
                 * @param {?} actions
                 * @return {?}
                 */
                function (actions) {
                    return root.dispatch(actions);
                })
            };
        };
        /**
         * @param {?} results
         * @return {?}
         */
        InternalStateOperations.prototype.setStateToTheCurrentWithNew = /**
         * @param {?} results
         * @return {?}
         */
        function (results) {
            /** @type {?} */
            var stateOperations = this.getRootStateOperations();
            // Get our current stream
            /** @type {?} */
            var currentState = stateOperations.getState();
            // Set the state to the current + new
            stateOperations.setState(__assign({}, currentState, results.defaults));
        };
        InternalStateOperations.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        InternalStateOperations.ctorParameters = function () { return [
            { type: StateStream },
            { type: InternalDispatcher },
            { type: NgxsConfig },
            { type: ConfigValidator }
        ]; };
        return InternalStateOperations;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} val
     * @return {?}
     */
    function simplePatch(val) {
        return (/**
         * @param {?} existingState
         * @return {?}
         */
        function (existingState) {
            /** @type {?} */
            var isArray = Array.isArray(val);
            /** @type {?} */
            var isPrimitive = typeof val !== 'object';
            if (isArray) {
                throw new Error('Patching arrays is not supported.');
            }
            if (isPrimitive) {
                throw new Error('Patching primitives is not supported.');
            }
            /** @type {?} */
            var newState = __assign({}, ((/** @type {?} */ (existingState))));
            for (var k in val) {
                newState[k] = val[k];
            }
            return (/** @type {?} */ (newState));
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State Context factory class
     * @ignore
     */
    var StateContextFactory = /** @class */ (function () {
        function StateContextFactory(_internalStateOperations) {
            this._internalStateOperations = _internalStateOperations;
        }
        /**
         * Create the state context
         */
        /**
         * Create the state context
         * @template T
         * @param {?} metadata
         * @return {?}
         */
        StateContextFactory.prototype.createStateContext = /**
         * Create the state context
         * @template T
         * @param {?} metadata
         * @return {?}
         */
        function (metadata) {
            /** @type {?} */
            var root = this._internalStateOperations.getRootStateOperations();
            /**
             * @param {?} currentAppState
             * @return {?}
             */
            function getState(currentAppState) {
                return getValue(currentAppState, metadata.depth);
            }
            /**
             * @param {?} currentAppState
             * @param {?} newValue
             * @return {?}
             */
            function setStateValue(currentAppState, newValue) {
                /** @type {?} */
                var newAppState = setValue(currentAppState, metadata.depth, newValue);
                root.setState(newAppState);
                return newAppState;
                // In doing this refactoring I noticed that there is a 'bug' where the
                // application state is returned instead of this state slice.
                // This has worked this way since the beginning see:
                // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts
                // This needs to be fixed, but is a 'breaking' change.
                // I will do this fix in a subsequent PR and we can decide how to handle it.
            }
            /**
             * @param {?} currentAppState
             * @param {?} stateOperator
             * @return {?}
             */
            function setStateFromOperator(currentAppState, stateOperator) {
                /** @type {?} */
                var local = getState(currentAppState);
                /** @type {?} */
                var newValue = stateOperator(local);
                return setStateValue(currentAppState, newValue);
            }
            /**
             * @param {?} value
             * @return {?}
             */
            function isStateOperator(value) {
                return typeof value === 'function';
            }
            return {
                getState: /**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var currentAppState = root.getState();
                    return getState(currentAppState);
                },
                patchState: /**
                 * @param {?} val
                 * @return {?}
                 */
                function (val) {
                    /** @type {?} */
                    var currentAppState = root.getState();
                    /** @type {?} */
                    var patchOperator = simplePatch(val);
                    return setStateFromOperator(currentAppState, patchOperator);
                },
                setState: /**
                 * @param {?} val
                 * @return {?}
                 */
                function (val) {
                    /** @type {?} */
                    var currentAppState = root.getState();
                    return isStateOperator(val)
                        ? setStateFromOperator(currentAppState, val)
                        : setStateValue(currentAppState, val);
                },
                dispatch: /**
                 * @param {?} actions
                 * @return {?}
                 */
                function (actions) {
                    return root.dispatch(actions);
                }
            };
        };
        StateContextFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateContextFactory.ctorParameters = function () { return [
            { type: InternalStateOperations }
        ]; };
        return StateContextFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var StoreValidators = /** @class */ (function () {
        function StoreValidators() {
        }
        /**
         * @param {?} name
         * @return {?}
         */
        StoreValidators.stateNameErrorMessage = /**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            return CONFIG_MESSAGES[VALIDATION_CODE.STATE_NAME](name);
        };
        /**
         * @param {?} name
         * @return {?}
         */
        StoreValidators.checkCorrectStateName = /**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            if (!name) {
                throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.STATE_NAME_PROPERTY]());
            }
            if (!this.stateNameRegex.test(name)) {
                throw new Error(this.stateNameErrorMessage(name));
            }
        };
        /**
         * @param {?} state
         * @param {?} statesByName
         * @return {?}
         */
        StoreValidators.checkStateNameIsUnique = /**
         * @param {?} state
         * @param {?} statesByName
         * @return {?}
         */
        function (state, statesByName) {
            /** @type {?} */
            var meta = this.getValidStateMeta(state);
            /** @type {?} */
            var stateName = (/** @type {?} */ ((/** @type {?} */ (meta)).name));
            /** @type {?} */
            var existingState = statesByName[stateName];
            if (existingState && existingState !== state) {
                throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.STATE_UNIQUE](stateName, state.name, existingState.name));
            }
            return stateName;
        };
        /**
         * @param {?} state
         * @return {?}
         */
        StoreValidators.getValidStateMeta = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            /** @type {?} */
            var meta = getStoreMetadata(state);
            if (!meta) {
                throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.STATE_DECORATOR]());
            }
            return meta;
        };
        StoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
        return StoreValidators;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State factory class
     * @ignore
     */
    var StateFactory = /** @class */ (function () {
        function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
            this._injector = _injector;
            this._config = _config;
            this._parentFactory = _parentFactory;
            this._actions = _actions;
            this._actionResults = _actionResults;
            this._stateContextFactory = _stateContextFactory;
            this._initialState = _initialState;
            this._connected = false;
            this._states = [];
            this._statesByName = {};
        }
        Object.defineProperty(StateFactory.prototype, "states", {
            get: /**
             * @return {?}
             */
            function () {
                return this._parentFactory ? this._parentFactory.states : this._states;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StateFactory.prototype, "statesByName", {
            get: /**
             * @return {?}
             */
            function () {
                return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @param {?} defaults
         * @return {?}
         */
        StateFactory.cloneDefaults = /**
         * @private
         * @param {?} defaults
         * @return {?}
         */
        function (defaults) {
            /** @type {?} */
            var value = {};
            if (Array.isArray(defaults)) {
                value = defaults.slice();
            }
            else if (isObject(defaults)) {
                value = __assign({}, defaults);
            }
            else if (defaults === undefined) {
                value = {};
            }
            else {
                value = defaults;
            }
            return value;
        };
        /**
         * @private
         * @param {?} stateClasses
         * @return {?}
         */
        StateFactory.checkStatesAreValid = /**
         * @private
         * @param {?} stateClasses
         * @return {?}
         */
        function (stateClasses) {
            stateClasses.forEach(StoreValidators.getValidStateMeta);
        };
        /**
         * Add a new state to the global defs.
         */
        /**
         * Add a new state to the global defs.
         * @param {?} stateClasses
         * @return {?}
         */
        StateFactory.prototype.add = /**
         * Add a new state to the global defs.
         * @param {?} stateClasses
         * @return {?}
         */
        function (stateClasses) {
            var e_1, _a;
            StateFactory.checkStatesAreValid(stateClasses);
            var newStates = this.addToStatesMap(stateClasses).newStates;
            if (!newStates.length)
                return [];
            /** @type {?} */
            var stateGraph = buildGraph(newStates);
            /** @type {?} */
            var sortedStates = topologicalSort(stateGraph);
            /** @type {?} */
            var depths = findFullParentPath(stateGraph);
            /** @type {?} */
            var nameGraph = nameToState(newStates);
            /** @type {?} */
            var bootstrappedStores = [];
            try {
                for (var sortedStates_1 = __values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                    var name_1 = sortedStates_1_1.value;
                    /** @type {?} */
                    var stateClass = nameGraph[name_1];
                    /** @type {?} */
                    var depth = depths[name_1];
                    /** @type {?} */
                    var meta = (/** @type {?} */ (stateClass[META_KEY]));
                    this.addRuntimeInfoToMeta(meta, depth);
                    /** @type {?} */
                    var stateMap = {
                        name: name_1,
                        depth: depth,
                        actions: meta.actions,
                        instance: this._injector.get(stateClass),
                        defaults: StateFactory.cloneDefaults(meta.defaults)
                    };
                    // ensure our store hasn't already been added
                    // but don't throw since it could be lazy
                    // loaded from different paths
                    if (!this.hasBeenMountedAndBootstrapped(name_1, depth)) {
                        bootstrappedStores.push(stateMap);
                    }
                    this.states.push(stateMap);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return bootstrappedStores;
        };
        /**
         * Add a set of states to the store and return the defaults
         */
        /**
         * Add a set of states to the store and return the defaults
         * @param {?} stateClasses
         * @return {?}
         */
        StateFactory.prototype.addAndReturnDefaults = /**
         * Add a set of states to the store and return the defaults
         * @param {?} stateClasses
         * @return {?}
         */
        function (stateClasses) {
            /** @type {?} */
            var classes = stateClasses || [];
            /** @type {?} */
            var states = this.add(classes);
            /** @type {?} */
            var defaults = states.reduce((/**
             * @param {?} result
             * @param {?} meta
             * @return {?}
             */
            function (result, meta) { return setValue(result, meta.depth, meta.defaults); }), {});
            return { defaults: defaults, states: states };
        };
        /**
         * Bind the actions to the handlers
         */
        /**
         * Bind the actions to the handlers
         * @return {?}
         */
        StateFactory.prototype.connectActionHandlers = /**
         * Bind the actions to the handlers
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._connected)
                return;
            this._actions
                .pipe(operators.filter((/**
             * @param {?} ctx
             * @return {?}
             */
            function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; })), operators.mergeMap((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var action = _a.action;
                return _this.invokeActions(_this._actions, (/** @type {?} */ (action))).pipe(operators.map((/**
                 * @return {?}
                 */
                function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); })), operators.defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), operators.catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    return rxjs.of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error })));
                })));
            })))
                .subscribe((/**
             * @param {?} ctx
             * @return {?}
             */
            function (ctx) { return _this._actionResults.next(ctx); }));
            this._connected = true;
        };
        /**
         * Invoke actions on the states.
         */
        /**
         * Invoke actions on the states.
         * @param {?} actions$
         * @param {?} action
         * @return {?}
         */
        StateFactory.prototype.invokeActions = /**
         * Invoke actions on the states.
         * @param {?} actions$
         * @param {?} action
         * @return {?}
         */
        function (actions$, action) {
            var e_2, _a, e_3, _b;
            /** @type {?} */
            var results = [];
            try {
                for (var _c = __values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var metadata = _d.value;
                    /** @type {?} */
                    var type = (/** @type {?} */ (getActionTypeFromInstance(action)));
                    /** @type {?} */
                    var actionMetas = metadata.actions[type];
                    if (actionMetas) {
                        try {
                            for (var actionMetas_1 = __values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                                var actionMeta = actionMetas_1_1.value;
                                /** @type {?} */
                                var stateContext = this._stateContextFactory.createStateContext(metadata);
                                try {
                                    /** @type {?} */
                                    var result = metadata.instance[actionMeta.fn](stateContext, action);
                                    if (result instanceof Promise) {
                                        result = rxjs.from(result);
                                    }
                                    if (result instanceof rxjs.Observable) {
                                        if (actionMeta.options.cancelUncompleted) {
                                            // todo: ofActionDispatched should be used with action class
                                            result = result.pipe(operators.takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                                        }
                                    }
                                    else {
                                        result = rxjs.of({}).pipe(operators.shareReplay());
                                    }
                                    results.push(result);
                                }
                                catch (e) {
                                    results.push(rxjs.throwError(e));
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (!results.length) {
                results.push(rxjs.of({}));
            }
            return rxjs.forkJoin(results);
        };
        /**
         * @private
         * @param {?} stateClasses
         * @return {?}
         */
        StateFactory.prototype.addToStatesMap = /**
         * @private
         * @param {?} stateClasses
         * @return {?}
         */
        function (stateClasses) {
            var e_4, _a;
            /** @type {?} */
            var newStates = [];
            /** @type {?} */
            var statesMap = this.statesByName;
            try {
                for (var stateClasses_1 = __values(stateClasses), stateClasses_1_1 = stateClasses_1.next(); !stateClasses_1_1.done; stateClasses_1_1 = stateClasses_1.next()) {
                    var stateClass = stateClasses_1_1.value;
                    /** @type {?} */
                    var stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
                    /** @type {?} */
                    var unmountedState = !statesMap[stateName];
                    if (unmountedState) {
                        newStates.push(stateClass);
                        statesMap[stateName] = stateClass;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (stateClasses_1_1 && !stateClasses_1_1.done && (_a = stateClasses_1.return)) _a.call(stateClasses_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return { newStates: newStates };
        };
        /**
         * @private
         * @param {?} meta
         * @param {?} depth
         * @return {?}
         */
        StateFactory.prototype.addRuntimeInfoToMeta = /**
         * @private
         * @param {?} meta
         * @param {?} depth
         * @return {?}
         */
        function (meta, depth) {
            meta.path = depth;
            meta.selectFromAppState = propGetter(depth.split('.'), this._config);
        };
        /**
         * @description
         * the method checks if the state has already been added to the tree
         * and completed the life cycle
         * @param name
         * @param path
         */
        /**
         * \@description
         * the method checks if the state has already been added to the tree
         * and completed the life cycle
         * @private
         * @param {?} name
         * @param {?} path
         * @return {?}
         */
        StateFactory.prototype.hasBeenMountedAndBootstrapped = /**
         * \@description
         * the method checks if the state has already been added to the tree
         * and completed the life cycle
         * @private
         * @param {?} name
         * @param {?} path
         * @return {?}
         */
        function (name, path) {
            /** @type {?} */
            var valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
            return this.statesByName[name] && valueIsBootstrappedInInitialState;
        };
        StateFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateFactory.ctorParameters = function () { return [
            { type: core.Injector },
            { type: NgxsConfig },
            { type: StateFactory, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: InternalActions },
            { type: InternalDispatchedActionResults },
            { type: StateContextFactory },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [internals.INITIAL_STATE_TOKEN,] }] }
        ]; };
        return StateFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LifecycleStateManager = /** @class */ (function () {
        function LifecycleStateManager(internalStateOperations, stateContextFactory, bootstrapper) {
            this.internalStateOperations = internalStateOperations;
            this.stateContextFactory = stateContextFactory;
            this.bootstrapper = bootstrapper;
        }
        /**
         * @template T
         * @param {?} action
         * @param {?} results
         * @return {?}
         */
        LifecycleStateManager.prototype.ngxsBootstrap = /**
         * @template T
         * @param {?} action
         * @param {?} results
         * @return {?}
         */
        function (action, results) {
            var _this = this;
            this.internalStateOperations
                .getRootStateOperations()
                .dispatch(action)
                .pipe(operators.filter((/**
             * @return {?}
             */
            function () { return !!results; })), operators.tap((/**
             * @return {?}
             */
            function () { return _this.invokeInit((/** @type {?} */ (results)).states); })), operators.mergeMap((/**
             * @return {?}
             */
            function () { return _this.bootstrapper.appBootstrapped$; })), operators.filter((/**
             * @param {?} appBootstrapped
             * @return {?}
             */
            function (appBootstrapped) { return !!appBootstrapped; })))
                .subscribe((/**
             * @return {?}
             */
            function () {
                _this.invokeBootstrap((/** @type {?} */ (results)).states);
            }));
        };
        /**
         * Invoke the init function on the states.
         */
        /**
         * Invoke the init function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
        LifecycleStateManager.prototype.invokeInit = /**
         * Invoke the init function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
        function (stateMetadatas) {
            this.invokeLifecycleHooks(stateMetadatas, "ngxsOnInit" /* NgxsOnInit */);
        };
        /**
         * Invoke the bootstrap function on the states.
         */
        /**
         * Invoke the bootstrap function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
        LifecycleStateManager.prototype.invokeBootstrap = /**
         * Invoke the bootstrap function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
        function (stateMetadatas) {
            this.invokeLifecycleHooks(stateMetadatas, "ngxsAfterBootstrap" /* NgxsAfterBootstrap */);
        };
        /**
         * @private
         * @param {?} stateMetadatas
         * @param {?} hook
         * @return {?}
         */
        LifecycleStateManager.prototype.invokeLifecycleHooks = /**
         * @private
         * @param {?} stateMetadatas
         * @param {?} hook
         * @return {?}
         */
        function (stateMetadatas, hook) {
            var e_1, _a;
            try {
                for (var stateMetadatas_1 = __values(stateMetadatas), stateMetadatas_1_1 = stateMetadatas_1.next(); !stateMetadatas_1_1.done; stateMetadatas_1_1 = stateMetadatas_1.next()) {
                    var metadata = stateMetadatas_1_1.value;
                    /** @type {?} */
                    var instance = metadata.instance;
                    if (instance[hook]) {
                        /** @type {?} */
                        var stateContext = this.stateContextFactory.createStateContext(metadata);
                        (/** @type {?} */ (instance[hook]))(stateContext);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (stateMetadatas_1_1 && !stateMetadatas_1_1.done && (_a = stateMetadatas_1.return)) _a.call(stateMetadatas_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        LifecycleStateManager.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        LifecycleStateManager.ctorParameters = function () { return [
            { type: InternalStateOperations },
            { type: StateContextFactory },
            { type: internals.NgxsBootstrapper }
        ]; };
        return LifecycleStateManager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';
    /** @type {?} */
    var selectorOptionsMetaAccessor = {
        getOptions: (/**
         * @param {?} target
         * @return {?}
         */
        function (target) {
            return (target && ((/** @type {?} */ (target)))[SELECTOR_OPTIONS_META_KEY]) || {};
        }),
        defineOptions: (/**
         * @param {?} target
         * @param {?} options
         * @return {?}
         */
        function (target, options) {
            if (!target)
                return;
            ((/** @type {?} */ (target)))[SELECTOR_OPTIONS_META_KEY] = options;
        })
    };
    /**
     * Function for creating a selector
     * @template T
     * @param {?} selectors The selectors to use to create the arguments of this function
     * @param {?} originalFn The original function being made into a selector
     * @param {?=} creationMetadata
     * @return {?}
     */
    function createSelector(selectors, originalFn, creationMetadata) {
        /** @type {?} */
        var containerClass = creationMetadata && creationMetadata.containerClass;
        /** @type {?} */
        var wrappedFn = (/** @type {?} */ ((/**
         * @param {...?} args
         * @return {?}
         */
        function wrappedSelectorFn() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            /** @type {?} */
            var returnValue = originalFn.apply(containerClass, args);
            if (returnValue instanceof Function) {
                /** @type {?} */
                var innerMemoizedFn = internals.memoize.apply(null, [returnValue]);
                return innerMemoizedFn;
            }
            return returnValue;
        })));
        /** @type {?} */
        var memoizedFn = internals.memoize(wrappedFn);
        /** @type {?} */
        var selectorMetaData = setupSelectorMetadata(memoizedFn, originalFn, creationMetadata);
        /** @type {?} */
        var runtimeInfo;
        /** @type {?} */
        var selectFromAppState = (/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            /** @type {?} */
            var results = [];
            runtimeInfo = runtimeInfo || getRuntimeSelectorInfo(selectorMetaData, selectors);
            var suppressErrors = runtimeInfo.selectorOptions.suppressErrors;
            var argumentSelectorFunctions = runtimeInfo.argumentSelectorFunctions;
            // Determine arguments from the app state using the selectors
            results.push.apply(results, __spread(argumentSelectorFunctions.map((/**
             * @param {?} argFn
             * @return {?}
             */
            function (argFn) { return argFn(state); }))));
            // if the lambda tries to access a something on the
            // state that doesn't exist, it will throw a TypeError.
            // since this is quite usual behaviour, we simply return undefined if so.
            try {
                return memoizedFn.apply(void 0, __spread(results));
            }
            catch (ex) {
                if (ex instanceof TypeError && suppressErrors) {
                    return undefined;
                }
                throw ex;
            }
        });
        selectorMetaData.selectFromAppState = selectFromAppState;
        return memoizedFn;
    }
    /**
     * @template T
     * @param {?} memoizedFn
     * @param {?} originalFn
     * @param {?} creationMetadata
     * @return {?}
     */
    function setupSelectorMetadata(memoizedFn, originalFn, creationMetadata) {
        /** @type {?} */
        var selectorMetaData = ensureSelectorMetadata(memoizedFn);
        selectorMetaData.originalFn = originalFn;
        /** @type {?} */
        var getExplicitSelectorOptions = (/**
         * @return {?}
         */
        function () { return ({}); });
        if (creationMetadata) {
            selectorMetaData.containerClass = creationMetadata.containerClass;
            selectorMetaData.selectorName = creationMetadata.selectorName;
            getExplicitSelectorOptions =
                creationMetadata.getSelectorOptions || getExplicitSelectorOptions;
        }
        /** @type {?} */
        var selectorMetaDataClone = __assign({}, selectorMetaData);
        selectorMetaData.getSelectorOptions = (/**
         * @return {?}
         */
        function () {
            return getCustomSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());
        });
        return selectorMetaData;
    }
    /**
     * @param {?} selectorMetaData
     * @param {?=} selectors
     * @return {?}
     */
    function getRuntimeSelectorInfo(selectorMetaData, selectors) {
        if (selectors === void 0) { selectors = []; }
        /** @type {?} */
        var selectorOptions = selectorMetaData.getSelectorOptions();
        /** @type {?} */
        var selectorsToApply = getSelectorsToApply(selectorMetaData, selectors);
        /** @type {?} */
        var argumentSelectorFunctions = selectorsToApply.map((/**
         * @param {?} selector
         * @return {?}
         */
        function (selector) { return getSelectorFn(selector); }));
        return {
            selectorOptions: selectorOptions,
            argumentSelectorFunctions: argumentSelectorFunctions
        };
    }
    /**
     * @param {?} selectorMetaData
     * @param {?} explicitOptions
     * @return {?}
     */
    function getCustomSelectorOptions(selectorMetaData, explicitOptions) {
        /** @type {?} */
        var selectorOptions = __assign({}, globalSelectorOptions.get(), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}), (selectorMetaData.getSelectorOptions() || {}), explicitOptions);
        return selectorOptions;
    }
    /**
     * @param {?} selectorMetaData
     * @param {?=} selectors
     * @return {?}
     */
    function getSelectorsToApply(selectorMetaData, selectors) {
        if (selectors === void 0) { selectors = []; }
        /** @type {?} */
        var selectorsToApply = [];
        /** @type {?} */
        var canInjectContainerState = selectors.length === 0 || selectorMetaData.getSelectorOptions().injectContainerState;
        /** @type {?} */
        var containerClass = selectorMetaData.containerClass;
        if (containerClass && canInjectContainerState) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            var metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push.apply(selectorsToApply, __spread(selectors));
        }
        return selectorsToApply;
    }
    /**
     * This function gets the selector function to be used to get the selected slice from the app state
     * @ignore
     * @param {?} selector
     * @return {?}
     */
    function getSelectorFn(selector) {
        /** @type {?} */
        var metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
        return (metadata && metadata.selectFromAppState) || selector;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Store = /** @class */ (function () {
        function Store(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, initialStateValue) {
            this._stateStream = _stateStream;
            this._internalStateOperations = _internalStateOperations;
            this._config = _config;
            this._internalExecutionStrategy = _internalExecutionStrategy;
            this.initStateStream(initialStateValue);
        }
        /**
         * Dispatches event(s).
         */
        /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
        Store.prototype.dispatch = /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
        function (event) {
            return this._internalStateOperations.getRootStateOperations().dispatch(event);
        };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.select = /**
         * @param {?} selector
         * @return {?}
         */
        function (selector) {
            var _this = this;
            /** @type {?} */
            var selectorFn = getSelectorFn(selector);
            return this._stateStream.pipe(operators.map(selectorFn), operators.catchError((/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                // if error is TypeError we swallow it to prevent usual errors with property access
                var suppressErrors = _this._config.selectorOptions.suppressErrors;
                if (err instanceof TypeError && suppressErrors) {
                    return rxjs.of(undefined);
                }
                // rethrow other errors
                return rxjs.throwError(err);
            })), operators.distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));
        };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.selectOnce = /**
         * @param {?} selector
         * @return {?}
         */
        function (selector) {
            return this.select(selector).pipe(operators.take(1));
        };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.selectSnapshot = /**
         * @param {?} selector
         * @return {?}
         */
        function (selector) {
            /** @type {?} */
            var selectorFn = getSelectorFn(selector);
            return selectorFn(this._stateStream.getValue());
        };
        /**
         * Allow the user to subscribe to the root of the state
         */
        /**
         * Allow the user to subscribe to the root of the state
         * @param {?=} fn
         * @return {?}
         */
        Store.prototype.subscribe = /**
         * Allow the user to subscribe to the root of the state
         * @param {?=} fn
         * @return {?}
         */
        function (fn) {
            return this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);
        };
        /**
         * Return the raw value of the state.
         */
        /**
         * Return the raw value of the state.
         * @return {?}
         */
        Store.prototype.snapshot = /**
         * Return the raw value of the state.
         * @return {?}
         */
        function () {
            return this._internalStateOperations.getRootStateOperations().getState();
        };
        /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         */
        /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         * @param {?} state
         * @return {?}
         */
        Store.prototype.reset = /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         * @param {?} state
         * @return {?}
         */
        function (state) {
            return this._internalStateOperations.getRootStateOperations().setState(state);
        };
        /**
         * @private
         * @param {?} initialStateValue
         * @return {?}
         */
        Store.prototype.initStateStream = /**
         * @private
         * @param {?} initialStateValue
         * @return {?}
         */
        function (initialStateValue) {
            /** @type {?} */
            var value = this._stateStream.value;
            /** @type {?} */
            var storeIsEmpty = !value || Object.keys(value).length === 0;
            if (storeIsEmpty) {
                /** @type {?} */
                var defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;
                /** @type {?} */
                var storeValues = defaultStateNotEmpty
                    ? internals.ObjectUtils.merge(this._config.defaultsState, initialStateValue)
                    : initialStateValue;
                this._stateStream.next(storeValues);
            }
        };
        Store.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        Store.ctorParameters = function () { return [
            { type: StateStream },
            { type: InternalStateOperations },
            { type: NgxsConfig },
            { type: InternalNgxsExecutionStrategy },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [internals.INITIAL_STATE_TOKEN,] }] }
        ]; };
        return Store;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Allows the select decorator to get access to the DI store.
     * \@internal only use in \@Select decorator
     * @ignore
     */
    var SelectFactory = /** @class */ (function () {
        function SelectFactory(store, config) {
            SelectFactory.store = store;
            SelectFactory.config = config;
        }
        SelectFactory.store = null;
        SelectFactory.config = null;
        SelectFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SelectFactory.ctorParameters = function () { return [
            { type: Store },
            { type: NgxsConfig }
        ]; };
        return SelectFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Init action
     */
    var   /**
     * Init action
     */
    InitState = /** @class */ (function () {
        function InitState() {
        }
        Object.defineProperty(InitState, "type", {
            get: /**
             * @return {?}
             */
            function () {
                // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
                return '@@INIT';
            },
            enumerable: true,
            configurable: true
        });
        return InitState;
    }());
    /**
     * Update action
     */
    var   /**
     * Update action
     */
    UpdateState = /** @class */ (function () {
        function UpdateState(addedStates) {
            this.addedStates = addedStates;
        }
        Object.defineProperty(UpdateState, "type", {
            get: /**
             * @return {?}
             */
            function () {
                // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
                return '@@UPDATE_STATE';
            },
            enumerable: true,
            configurable: true
        });
        return UpdateState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Root module
     * @ignore
     */
    var NgxsRootModule = /** @class */ (function () {
        function NgxsRootModule(factory, internalStateOperations, _store, _select, states, config, lifecycleStateManager) {
            if (states === void 0) { states = []; }
            globalSelectorOptions.set(config.selectorOptions || {});
            // add stores to the state graph and return their defaults
            /** @type {?} */
            var results = factory.addAndReturnDefaults(states);
            internalStateOperations.setStateToTheCurrentWithNew(results);
            // connect our actions stream
            factory.connectActionHandlers();
            // dispatch the init action and invoke init and bootstrap functions after
            lifecycleStateManager.ngxsBootstrap(new InitState(), results);
        }
        NgxsRootModule.decorators = [
            { type: core.NgModule }
        ];
        /** @nocollapse */
        NgxsRootModule.ctorParameters = function () { return [
            { type: StateFactory },
            { type: InternalStateOperations },
            { type: Store },
            { type: SelectFactory },
            { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [ROOT_STATE_TOKEN,] }] },
            { type: NgxsConfig },
            { type: LifecycleStateManager }
        ]; };
        return NgxsRootModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Feature module
     * @ignore
     */
    var NgxsFeatureModule = /** @class */ (function () {
        function NgxsFeatureModule(_store, internalStateOperations, factory, states, lifecycleStateManager) {
            if (states === void 0) { states = []; }
            // Since FEATURE_STATE_TOKEN is a multi token, we need to
            // flatten it [[Feature1State, Feature2State], [Feature3State]]
            /** @type {?} */
            var flattenedStates = NgxsFeatureModule.flattenStates(states);
            // add stores to the state graph and return their defaults
            /** @type {?} */
            var results = factory.addAndReturnDefaults(flattenedStates);
            if (results.states.length) {
                internalStateOperations.setStateToTheCurrentWithNew(results);
                // dispatch the update action and invoke init and bootstrap functions after
                lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);
            }
        }
        /**
         * @private
         * @param {?=} states
         * @return {?}
         */
        NgxsFeatureModule.flattenStates = /**
         * @private
         * @param {?=} states
         * @return {?}
         */
        function (states) {
            if (states === void 0) { states = []; }
            return states.reduce((/**
             * @param {?} total
             * @param {?} values
             * @return {?}
             */
            function (total, values) { return total.concat(values); }), []);
        };
        NgxsFeatureModule.decorators = [
            { type: core.NgModule }
        ];
        /** @nocollapse */
        NgxsFeatureModule.ctorParameters = function () { return [
            { type: Store },
            { type: InternalStateOperations },
            { type: StateFactory },
            { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [FEATURE_STATE_TOKEN,] }] },
            { type: LifecycleStateManager }
        ]; };
        return NgxsFeatureModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Ngxs Module
     */
    var NgxsModule = /** @class */ (function () {
        function NgxsModule() {
        }
        /**
         * Root module factory
         */
        /**
         * Root module factory
         * @param {?=} states
         * @param {?=} options
         * @return {?}
         */
        NgxsModule.forRoot = /**
         * Root module factory
         * @param {?=} states
         * @param {?=} options
         * @return {?}
         */
        function (states, options) {
            if (states === void 0) { states = []; }
            if (options === void 0) { options = {}; }
            return {
                ngModule: NgxsRootModule,
                providers: __spread([
                    StateFactory,
                    StateContextFactory,
                    Actions,
                    InternalActions,
                    internals.NgxsBootstrapper,
                    ConfigValidator,
                    HostEnvironment,
                    LifecycleStateManager,
                    InternalDispatcher,
                    InternalDispatchedActionResults,
                    InternalStateOperations,
                    InternalNgxsExecutionStrategy,
                    Store,
                    StateStream,
                    SelectFactory,
                    PluginManager
                ], states, NgxsModule.ngxsTokenProviders(states, options))
            };
        };
        /**
         * Feature module factory
         */
        /**
         * Feature module factory
         * @param {?=} states
         * @return {?}
         */
        NgxsModule.forFeature = /**
         * Feature module factory
         * @param {?=} states
         * @return {?}
         */
        function (states) {
            if (states === void 0) { states = []; }
            return {
                ngModule: NgxsFeatureModule,
                providers: __spread([
                    StateFactory,
                    PluginManager
                ], states, [
                    {
                        provide: FEATURE_STATE_TOKEN,
                        multi: true,
                        useValue: states
                    }
                ])
            };
        };
        /**
         * @private
         * @param {?} states
         * @param {?} options
         * @return {?}
         */
        NgxsModule.ngxsTokenProviders = /**
         * @private
         * @param {?} states
         * @param {?} options
         * @return {?}
         */
        function (states, options) {
            return [
                {
                    provide: NG_DEV_MODE,
                    useFactory: NgxsModule.isAngularInTestMode
                },
                {
                    provide: NG_TEST_MODE,
                    useFactory: NgxsModule.isAngularDevMode
                },
                {
                    provide: NGXS_EXECUTION_STRATEGY,
                    useClass: options.executionStrategy || DispatchOutsideZoneNgxsExecutionStrategy
                },
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                },
                {
                    provide: NgxsModule.ROOT_OPTIONS,
                    useValue: options
                },
                {
                    provide: NgxsConfig,
                    useFactory: NgxsModule.ngxsConfigFactory,
                    deps: [NgxsModule.ROOT_OPTIONS]
                },
                {
                    provide: core.APP_BOOTSTRAP_LISTENER,
                    useFactory: NgxsModule.appBootstrapListenerFactory,
                    multi: true,
                    deps: [internals.NgxsBootstrapper]
                },
                {
                    provide: internals.INITIAL_STATE_TOKEN,
                    useFactory: NgxsModule.getInitialState
                }
            ];
        };
        /**
         * @private
         * @param {?} options
         * @return {?}
         */
        NgxsModule.ngxsConfigFactory = /**
         * @private
         * @param {?} options
         * @return {?}
         */
        function (options) {
            return Object.assign(new NgxsConfig(), options);
        };
        /**
         * @private
         * @param {?} bootstrapper
         * @return {?}
         */
        NgxsModule.appBootstrapListenerFactory = /**
         * @private
         * @param {?} bootstrapper
         * @return {?}
         */
        function (bootstrapper) {
            return (/**
             * @return {?}
             */
            function () { return bootstrapper.bootstrap(); });
        };
        /**
         * @private
         * @return {?}
         */
        NgxsModule.isAngularInTestMode = /**
         * @private
         * @return {?}
         */
        function () {
            return (/**
             * @return {?}
             */
            function () { return internals.isAngularInTestMode(); });
        };
        /**
         * @private
         * @return {?}
         */
        NgxsModule.isAngularDevMode = /**
         * @private
         * @return {?}
         */
        function () {
            return (/**
             * @return {?}
             */
            function () { return core.isDevMode(); });
        };
        /**
         * @private
         * @return {?}
         */
        NgxsModule.getInitialState = /**
         * @private
         * @return {?}
         */
        function () {
            return internals.InitialState.pop();
        };
        NgxsModule.ROOT_OPTIONS = new core.InjectionToken('ROOT_OPTIONS');
        NgxsModule.decorators = [
            { type: core.NgModule }
        ];
        return NgxsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorates a method with a action information.
     * @param {?} actions
     * @param {?=} options
     * @return {?}
     */
    function Action(actions, options) {
        return (/**
         * @param {?} target
         * @param {?} name
         * @return {?}
         */
        function (target, name) {
            var e_1, _a;
            /** @type {?} */
            var isStaticMethod = target.hasOwnProperty('prototype');
            if (isStaticMethod) {
                throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.ACTION_DECORATOR]());
            }
            /** @type {?} */
            var meta = ensureStoreMetadata(target.constructor);
            if (!Array.isArray(actions)) {
                actions = [actions];
            }
            try {
                for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                    var action = actions_1_1.value;
                    /** @type {?} */
                    var type = action.type;
                    if (!meta.actions[type]) {
                        meta.actions[type] = [];
                    }
                    meta.actions[type].push({
                        fn: name,
                        options: options || {},
                        type: type
                    });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorates a class with ngxs state information.
     * @template T
     * @param {?} options
     * @return {?}
     */
    function State(options) {
        /**
         * @param {?} inheritedStateClass
         * @return {?}
         */
        function getStateOptions(inheritedStateClass) {
            /** @type {?} */
            var inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};
            return (/** @type {?} */ (__assign({}, inheritanceOptions, options)));
        }
        /**
         * @param {?} params
         * @return {?}
         */
        function mutateMetaData(params) {
            var meta = params.meta, inheritedStateClass = params.inheritedStateClass, optionsWithInheritance = params.optionsWithInheritance;
            var children = optionsWithInheritance.children, defaults = optionsWithInheritance.defaults, name = optionsWithInheritance.name;
            StoreValidators.checkCorrectStateName(name);
            if (inheritedStateClass.hasOwnProperty(META_KEY)) {
                /** @type {?} */
                var inheritedMeta = inheritedStateClass[META_KEY] || {};
                meta.actions = __assign({}, meta.actions, inheritedMeta.actions);
            }
            meta.children = children;
            meta.defaults = defaults;
            meta.name = name;
        }
        return (/**
         * @param {?} target
         * @return {?}
         */
        function (target) {
            /** @type {?} */
            var stateClass = target;
            /** @type {?} */
            var meta = ensureStoreMetadata(stateClass);
            /** @type {?} */
            var inheritedStateClass = Object.getPrototypeOf(stateClass);
            /** @type {?} */
            var optionsWithInheritance = getStateOptions(inheritedStateClass);
            mutateMetaData({ meta: meta, inheritedStateClass: inheritedStateClass, optionsWithInheritance: optionsWithInheritance });
            stateClass[META_OPTIONS_KEY] = optionsWithInheritance;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DOLLAR_CHAR_CODE = 36;
    /**
     * @template T
     * @param {?} selector
     * @return {?}
     */
    function createSelectObservable(selector) {
        if (!SelectFactory.store) {
            throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.SELECT_FACTORY_NOT_CONNECTED]());
        }
        return SelectFactory.store.select(selector);
    }
    /**
     * @param {?} name
     * @param {?=} rawSelector
     * @param {?=} paths
     * @return {?}
     */
    function createSelectorFn(name, rawSelector, paths) {
        if (paths === void 0) { paths = []; }
        rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;
        if (typeof rawSelector === 'string') {
            /** @type {?} */
            var propsArray = paths.length
                ? __spread([rawSelector], paths) : rawSelector.split('.');
            return propGetter(propsArray, (/** @type {?} */ (SelectFactory.config)));
        }
        else if (rawSelector[META_KEY] && rawSelector[META_KEY].path) {
            return propGetter(rawSelector[META_KEY].path.split('.'), (/** @type {?} */ (SelectFactory.config)));
        }
        return rawSelector;
    }
    /**
     * \@example If `foo$` => make it just `foo`
     * @param {?} name
     * @return {?}
     */
    function removeDollarAtTheEnd(name) {
        /** @type {?} */
        var lastCharIndex = name.length - 1;
        /** @type {?} */
        var dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
        return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorator for selecting a slice of state from the store.
     * @param {?=} rawSelector
     * @param {...?} paths
     * @return {?}
     */
    function Select(rawSelector) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        return (/**
         * @param {?} target
         * @param {?} propertyKey
         * @return {?}
         */
        function (target, propertyKey) {
            var _a;
            /** @type {?} */
            var name = propertyKey.toString();
            /** @type {?} */
            var selectorId = "__" + name + "__selector";
            /** @type {?} */
            var selector = createSelectorFn(name, rawSelector, paths);
            Object.defineProperties(target, (_a = {},
                _a[selectorId] = {
                    writable: true,
                    enumerable: false,
                    configurable: true
                },
                _a[name] = {
                    enumerable: true,
                    configurable: true,
                    get: /**
                     * @return {?}
                     */
                    function () {
                        return this[selectorId] || (this[selectorId] = createSelectObservable(selector));
                    }
                },
                _a));
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorator for setting selector options at a method or class level.
     * @param {?} options
     * @return {?}
     */
    function SelectorOptions(options) {
        return (/** @type {?} */ (((/**
         * @template T
         * @param {?} target
         * @param {?} methodName
         * @param {?} descriptor
         * @return {?}
         */
        function decorate(target, methodName, descriptor) {
            if (methodName) {
                // Method Decorator
                /** @type {?} */
                var originalFn = descriptor.value || ((/** @type {?} */ (descriptor))).originalFn;
                if (originalFn) {
                    selectorOptionsMetaAccessor.defineOptions(originalFn, options);
                }
            }
            else {
                // Class Decorator
                selectorOptionsMetaAccessor.defineOptions(target, options);
            }
        }))));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorator for memoizing a state selector.
     * @param {?=} selectors
     * @return {?}
     */
    function Selector(selectors) {
        return (/**
         * @template T
         * @param {?} target
         * @param {?} key
         * @param {?} descriptor
         * @return {?}
         */
        function (target, key, descriptor) {
            /** @type {?} */
            var isNotMethod = !(descriptor && descriptor.value !== null);
            if (isNotMethod) {
                throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.SELECTOR_DECORATOR]());
            }
            /** @type {?} */
            var originalFn = descriptor.value;
            /** @type {?} */
            var memoizedFn = null;
            /** @type {?} */
            var newDescriptor = {
                configurable: true,
                get: /**
                 * @return {?}
                 */
                function () {
                    // Selector initialisation deferred to here so that it is at runtime, not decorator parse time
                    memoizedFn =
                        memoizedFn ||
                            createSelector(selectors, (/** @type {?} */ (originalFn)), {
                                containerClass: target,
                                selectorName: key.toString(),
                                getSelectorOptions: /**
                                 * @return {?}
                                 */
                                function () {
                                    return {};
                                }
                            });
                    return memoizedFn;
                }
            };
            // Add hidden property to descriptor
            ((/** @type {?} */ (newDescriptor)))['originalFn'] = originalFn;
            return newDescriptor;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NoopNgxsExecutionStrategy = /** @class */ (function () {
        function NoopNgxsExecutionStrategy() {
        }
        /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        NoopNgxsExecutionStrategy.prototype.enter = /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            return func();
        };
        /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        NoopNgxsExecutionStrategy.prototype.leave = /**
         * @template T
         * @param {?} func
         * @return {?}
         */
        function (func) {
            return func();
        };
        NoopNgxsExecutionStrategy.decorators = [
            { type: core.Injectable }
        ];
        return NoopNgxsExecutionStrategy;
    }());

    exports.Action = Action;
    exports.Actions = Actions;
    exports.InitState = InitState;
    exports.NGXS_PLUGINS = NGXS_PLUGINS;
    exports.NgxsModule = NgxsModule;
    exports.NoopNgxsExecutionStrategy = NoopNgxsExecutionStrategy;
    exports.Select = Select;
    exports.Selector = Selector;
    exports.SelectorOptions = SelectorOptions;
    exports.State = State;
    exports.StateStream = StateStream;
    exports.Store = Store;
    exports.UpdateState = UpdateState;
    exports.actionMatcher = actionMatcher;
    exports.createSelector = createSelector;
    exports.ensureSelectorMetadata = ensureSelectorMetadata;
    exports.ensureStoreMetadata = ensureStoreMetadata;
    exports.getActionTypeFromInstance = getActionTypeFromInstance;
    exports.getSelectorMetadata = getSelectorMetadata;
    exports.getStoreMetadata = getStoreMetadata;
    exports.getValue = getValue;
    exports.ofAction = ofAction;
    exports.ofActionCanceled = ofActionCanceled;
    exports.ofActionCompleted = ofActionCompleted;
    exports.ofActionDispatched = ofActionDispatched;
    exports.ofActionErrored = ofActionErrored;
    exports.ofActionSuccessful = ofActionSuccessful;
    exports.setValue = setValue;
    exports.a = OrderedSubject;
    exports.b = InternalActions;
    exports.e = ROOT_STATE_TOKEN;
    exports.f = FEATURE_STATE_TOKEN;
    exports.g = NG_TEST_MODE;
    exports.h = NG_DEV_MODE;
    exports.i = SELECTOR_META_KEY;
    exports.j = NgxsConfig;
    exports.k = NGXS_EXECUTION_STRATEGY;
    exports.l = NgxsRootModule;
    exports.m = StateFactory;
    exports.n = InternalDispatchedActionResults;
    exports.o = InternalDispatcher;
    exports.p = StateContextFactory;
    exports.q = InternalStateOperations;
    exports.r = PluginManager;
    exports.s = InternalNgxsExecutionStrategy;
    exports.t = ConfigValidator;
    exports.u = HostEnvironment;
    exports.v = SelectFactory;
    exports.w = LifecycleStateManager;
    exports.x = NgxsFeatureModule;
    exports.y = DispatchOutsideZoneNgxsExecutionStrategy;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngxs-store.umd.js.map
